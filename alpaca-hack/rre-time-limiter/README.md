## Challenge
素数の配列と、フラグをそれぞれの素数で割った余りの配列が与えられるので、フラグを推測せよ
```python
import os
from Crypto.Util.number import bytes_to_long

flag = os.getenv("FLAG", "Alpaca{EXAMPLE}").encode()
flag = bytes_to_long(flag)

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349]
out = [flag % p for p in primes]
print(out)
```

## Solution

$$ outputs[n] + primes[n] * k = flag $$

調べたら良さそうなのがあった

```
与えられた k 個の整数 m1, m2, ..., mk がどの二つも互いに素ならば、任意に与えられる整数 a1, a2, ..., ak に対し

x ≡ a1 (mod m1),
x ≡ a2 (mod m2),
…
x ≡ ak (mod mk)
を満たす整数 x が m1m2…mk を法として一意的に存在する。
```

ref: https://qiita.com/masa0599/items/2c93189dcc6beee5d8c5
ref: https://ja.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E3%81%AE%E5%89%B0%E4%BD%99%E5%AE%9A%E7%90%86

中国余剰定理という国の名前を冠した定理があるらしい

毎度おなじみのsympyに実装されてるので使うだけ

## Final Source
```python
"""
output[n] + primes[n] * k = flag
"""

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349]
outputs = [1, 2, 0, 4, 8, 9, 8, 13, 16, 27, 0, 17, 17, 28, 20, 6, 28, 4, 47, 30, 37, 56, 57, 77, 35, 57, 89, 70, 27, 26, 108, 124, 25, 75, 122, 54, 64, 42, 158, 25, 68, 90, 89, 42, 90, 147, 124, 148, 225, 50, 182, 5, 162, 159, 252, 129, 145, 24, 119, 41, 215, 264, 299, 51, 203, 24, 18, 38, 55, 266]

from sympy.ntheory.modular import crt
from Crypto.Util.number import long_to_bytes

flag, _ = crt(primes, outputs)
print(long_to_bytes(flag).decode())
```
